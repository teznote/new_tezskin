import type { Values } from './config';
import type { MasterCSS } from './core';
export declare class Rule {
    readonly className: string;
    readonly meta: RuleMeta;
    css: MasterCSS;
    readonly at: Record<string, string>;
    readonly priority: number;
    readonly natives: RuleNative[];
    animationNames: string[];
    config: RuleConfig;
    constructor(className: string, meta: RuleMeta, css: MasterCSS);
    get values(): Record<string, string | number>;
    get text(): string;
    resolveValue(value: any, unit: any): any;
    analyzeUnitValue(token: string, unit?: string): {
        value: string;
        unit: string;
    };
}
export interface Rule {
    prefix?: string;
    token?: string;
    vendorPrefixSelectors?: Record<string, string[]>;
    vendorSuffixSelectors?: Record<string, string[]>;
    important?: boolean;
    media?: MediaQuery;
    direction?: string;
    theme?: string;
    unitToken?: string;
    hasWhere?: boolean;
    order?: number;
    constructor: {
        match?(name: string, matches: RegExp, colorThemesMap: Record<string, Record<string, string>>, colorNames: string[]): RuleMeta;
    };
}
export interface RuleNative {
    text: string;
    theme: string;
    cssRule?: CSSRule;
}
export interface MediaFeatureRule {
    token: string;
    tokenType?: string;
    operator?: string;
    value?: number;
    unit?: string;
}
export interface MediaQuery {
    token: string;
    features?: {
        [key: string]: MediaFeatureRule;
    };
    type?: string;
}
export declare type PropValue = string | number;
export declare type Declarations = Record<string, PropValue | PropValue[] | Record<string, PropValue>>;
export interface RuleMeta {
    origin?: 'match' | 'semantics';
    value?: [string, string | Record<string, string>];
    config?: RuleConfig;
}
export interface RuleConfig {
    id?: string;
    match?: string;
    separators?: string[];
    colored?: boolean;
    unit?: any;
    native?: string | true;
    order?: number | ((this: Rule, prefix: string) => number);
    values?: Values;
    analyze?(this: Rule, className: string): [valueToken: string, prefixToken?: string];
    transform?(this: Rule, value: string): string;
    declare?(this: Rule, value: string, unit: string): Record<string, any>;
    delete?(this: Rule, className: string): void;
    create?(this: Rule, className: string): void;
    insert?(this: Rule): void;
}
