'use strict';

const path = require('path');
const fs = require('fs');
const resolve = require('resolve');
const clap = require('clap');
const index = require('./reporter/index.cjs');
const helpers = require('./helpers.cjs');
const version = require('./version.cjs');

async function readStdin() {
    const buffer = [];

    for await (const chunk of process.stdin) {
        buffer.push(chunk);
    }

    return buffer.join('');
}

function printResult(result, reporter) {
    const output = reporter(result);

    if (Object.keys(result).length > 0) {
        console.error(output);
        process.exit(1);
    }

    if (output) {
        console.log(output);
    }
}

const command = clap.command('csstree-validate [fileOrDir]')
    .version(version.version)
    .option(
        '-r, --reporter <nameOrFile>',
        'Output formatter: console (default), checkstyle, json, gnu or <path to a module>',
        (nameOrFile) => {
            const modulePath = path.resolve(process.cwd(), nameOrFile);

            if (fs.existsSync(modulePath)) {
                return (function (t) { return Promise.resolve().then(function () { return require(t); }); })(modulePath);
            }

            if (!hasOwnProperty.call(index, nameOrFile)) {
                try {
                    const resolvedPath = resolve.sync(nameOrFile, { basedir: process.cwd() });
                    return (function (t) { return Promise.resolve().then(function () { return require(t); }); })(resolvedPath);
                } catch (e) {}

                throw new clap.Error('Wrong value for reporter: ' + nameOrFile);
            }

            return nameOrFile;
        },
        'console'
    )
    .action(async ({ options, args }) => {
        const inputPath = args[0];
        const reporter = typeof options.reporter === 'string'
            ? index[options.reporter]
            : (await options.reporter).default;

        if (process.stdin.isTTY && !inputPath) {
            command.run(['--help']);
            return;
        }

        if (!inputPath) {
            readStdin().then(input =>
                printResult(helpers.validateString(input, '<stdin>'), reporter)
            );
        } else {
            if (!fs.existsSync(inputPath)) {
                throw new clap.Error(`ERROR! No such file or directory: ${inputPath}`);
            }

            printResult(helpers.validatePath(args[0]), reporter);
        }
    });

const run = command.run.bind(command);
function isCliError(err) {
    return err instanceof clap.Error;
}

exports.isCliError = isCliError;
exports.run = run;
